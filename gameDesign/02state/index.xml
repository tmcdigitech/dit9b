<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>State on TMC - 9 Digital Tech Semester 1</title><link>https://tmcdigitech.github.io/dit9a/gameDesign/02state/</link><description>Recent content in State on TMC - 9 Digital Tech Semester 1</description><generator>Hugo -- gohugo.io</generator><language>en-au</language><atom:link href="https://tmcdigitech.github.io/dit9a/gameDesign/02state/index.xml" rel="self" type="application/rss+xml"/><item><title>What is state?</title><link>https://tmcdigitech.github.io/dit9a/gameDesign/02state/stateWhatIs/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://tmcdigitech.github.io/dit9a/gameDesign/02state/stateWhatIs/</guid><description>What is state? Imagine you are enjoying a particularly engaging session of Uno with some friends, and by a peculiar set of circumstances you are required to pack up the game back into its pack, but you and your friends want to be able to resume exactly where you are when you next meet. What would you have to record so that you can restore the game exactly as it is right now?</description></item><item><title>Reacting to and changing state</title><link>https://tmcdigitech.github.io/dit9a/gameDesign/02state/stateReacting/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://tmcdigitech.github.io/dit9a/gameDesign/02state/stateReacting/</guid><description>In all computer games, the game proceeds a teeny bit at a time, with each of the agents in the game making decisions about what to do next based on the current state, which then changes the game state, and then the agents all make a new set of decisions, and the game state changes again. From outside this can appear as a smooth, seamless and continuous process, but it is always made of little, discrete moves.</description></item><item><title>Problems with state</title><link>https://tmcdigitech.github.io/dit9a/gameDesign/02state/stateProblems/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://tmcdigitech.github.io/dit9a/gameDesign/02state/stateProblems/</guid><description>Keep it simple Broadly speaking, the more state your program has, the more complex it is, and thus the more opportunities there are for mistakes. This should encourage us to look for a solution with as little state information as possible. As a simple example, in a fighting game, it is important to know whether a character is alive or dead, and how much health they have. So you might think to have an integer to keep track of health, and a couple of boolean flags to keep track of the character&amp;rsquo;s life status:</description></item><item><title>The update/draw cycle</title><link>https://tmcdigitech.github.io/dit9a/gameDesign/02state/updateDrawCycle/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://tmcdigitech.github.io/dit9a/gameDesign/02state/updateDrawCycle/</guid><description>In Pygame Zero, as with most game engines, the code that manages the game state is separate from the code that handles the display. In Pygame Zero, there are two main functions:
update(), which responds to inputs and manages the game state, and draw(), which coordinates updating the screen to match the game state. stateDiagram-v2 direction LR [*] --> update() update() --> draw() draw() --> update() Where possible, these two functions will be run, update then draw, update then draw, 60 times per second.</description></item><item><title/><link>https://tmcdigitech.github.io/dit9a/gameDesign/02state/maintainingState/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://tmcdigitech.github.io/dit9a/gameDesign/02state/maintainingState/</guid><description/></item></channel></rss>